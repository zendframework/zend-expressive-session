{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-expressive-session-cache Repository abandoned 2019-12-31 This repository has moved to mezzio/mezzio-session-cache . This library provides a PSR-6 session persistence adapter for zend-expressive-session . Installation Run the following to install this library: $ composer require zendframework/zend-expressive-session-cache Documentation Browse the documentation online at https://docs.zendframework.com/zend-expressive-session-cache/ Support Issues Chat Forum","title":"Home"},{"location":"#zend-expressive-session-cache","text":"","title":"zend-expressive-session-cache"},{"location":"#repository-abandoned-2019-12-31","text":"This repository has moved to mezzio/mezzio-session-cache . This library provides a PSR-6 session persistence adapter for zend-expressive-session .","title":"Repository abandoned 2019-12-31"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-expressive-session-cache","title":"Installation"},{"location":"#documentation","text":"Browse the documentation online at https://docs.zendframework.com/zend-expressive-session-cache/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"v1/config/","text":"Configuration This package allows configuring the following items: The PSR-6 CacheItemPoolInterface service to use. The session cookie name. The session cookie domain. The session cookie path. The session cookie secure option. The session cookie httponly option. The cache limiter (which controls how resources using sessions are cached by the browser). When the session expires. When the resource using a session was last modified. Whether or not to create a persistent session cookie (i.e., one that will not expire when the browser is closed). This document details how to configure each of these items. Config service This package looks for a service named config that returns an array or array-like value. Inside this value, it looks for a key named zend-expressive-session-cache , which is expected to be an associative array or object that acts like an associative array. return [ 'zend-expressive-session-cache' => [ // key/value pairs ], ]; CacheItemPoolInterface By default, the factory will look for a service named Psr\\Cache\\CacheItemPoolInterface . If found, that service will be used to seed the persistence adapter. You may also provide a cache_item_pool_service configuration value. If present, this service name will be queried instead. Using a global pool To use a global cache item pool, configure the PSR-6 CacheItemPoolInterface service in your dependency configuration: use Psr\\Cache\\CacheItemPoolInterface; return [ 'dependencies' => [ 'factories' => [ CacheItemPoolInterface::class => FactoryProvidingACachePool::class, ], ], ]; Using a named pool To use a specific cache item pool: use Psr\\Cache\\CacheItemPoolInterface; return [ 'dependencies' => [ 'factories' => [ 'MoreSpecificPool' => FactoryProvidingACachePool::class, ], ], 'zend-expressive-session-cache' => [ 'cache_item_pool_service' => 'MoreSpecificPool', ], ]; Non-Pool configuration As noted earlier, you may configure a number of other values to customize your persistence adapter. The following is example configuration, with inline comments detailing expected and default values. use Psr\\Cache\\CacheItemPoolInterface; return [ 'zend-expressive-session-cache' => [ // Detailed in the above section; allows using a different // cache item pool than the global one. 'cache_item_pool_service' => CacheItemPoolInterface::class, // The name of the session cookie. This name must comply with // the syntax outlined in https://tools.ietf.org/html/rfc6265.html 'cookie_name' => 'PHPSESSION', // The (sub)domain that the cookie is available to. Setting this // to a subdomain (such as 'www.example.com') will make the cookie // available to that subdomain and all other sub-domains of it // (i.e. w2.www.example.com). To make the cookie available to the // whole domain (including all subdomains of it), simply set the // value to the domain name ('example.com', in this case). // Leave this null to use browser default (current hostname). 'cookie_domain' => null, // The path prefix of the cookie domain to which it applies. 'cookie_path' => '/', // Indicates that the cookie should only be transmitted over a // secure HTTPS connection from the client. When set to TRUE, the // cookie will only be set if a secure connection exists. 'cookie_secure' => false, // When TRUE the cookie will be made accessible only through the // HTTP protocol. This means that the cookie won't be accessible // by scripting languages, such as JavaScript. 'cookie_http_only' => false, // Governs the various cache control headers emitted when // a session cookie is provided to the client. Value may be one // of \"nocache\", \"public\", \"private\", or \"private_no_expire\"; // semantics are the same as outlined in // http://php.net/session_cache_limiter 'cache_limiter' => 'nocache', // When the cache and the cookie should expire, in seconds. Defaults // to 180 minutes. 'cache_expire' => 10800, // An integer value indicating when the resource to which the session // applies was last modified. If not provided, it uses the last // modified time of, in order, // - the public/index.php file of the current working directory // - the index.php file of the current working directory // - the current working directory 'last_modified' => null, // A boolean value indicating whether or not the session cookie // should persist. By default, this is disabled (false); passing // a boolean true value will enable the feature. When enabled, the // cookie will be generated with an Expires directive equal to the // the current time plus the cache_expire value as noted above. // // As of 1.2.0, developers may define the session TTL by calling the // session instance's `persistSessionFor(int $duration)` method. When // that method has been called, the engine will use that value even if // the below flag is toggled off. 'persistent' => false, ], ]; Using the service By default, this package define the service Zend\\Expressive\\Session\\Cache\\CacheSessionPersistence , assigning it to the factory Zend\\Expressive\\Session\\Cache\\CacheSessionPersistenceFactory . After you have installed the package, you will need to tell your application to use this service when using the SessionMiddleware . The SessionMiddleware looks for the service Zend\\Expressive\\Session\\SessionPersistenceInterface . You can tell your container to use the CacheSessionPersistence in two different ways. First, you can alias it: // in config/autoload/dependencies.global.php: use Zend\\Expressive\\Session\\Cache\\CacheSessionPersistence; use Zend\\Expressive\\Session\\SessionPersistenceInterface; return [ 'dependencies' => [ 'aliases' => [ SessionPersistenceInterface::class => CacheSessionPersistence::class, ], ], ]; Second, you can instead assign the SessionPersistenceInterface service to the factory for the CacheSessionPersistence implementation: // in config/autoload/dependencies.global.php: use Zend\\Expressive\\Session\\Cache\\CacheSessionPersistenceFactory; use Zend\\Expressive\\Session\\SessionPersistenceInterface; return [ 'dependencies' => [ 'factories' => [ SessionPersistenceInterface::class => CacheSessionPersistenceFactory::class, ], ], ];","title":"Configuration"},{"location":"v1/config/#configuration","text":"This package allows configuring the following items: The PSR-6 CacheItemPoolInterface service to use. The session cookie name. The session cookie domain. The session cookie path. The session cookie secure option. The session cookie httponly option. The cache limiter (which controls how resources using sessions are cached by the browser). When the session expires. When the resource using a session was last modified. Whether or not to create a persistent session cookie (i.e., one that will not expire when the browser is closed). This document details how to configure each of these items.","title":"Configuration"},{"location":"v1/config/#config-service","text":"This package looks for a service named config that returns an array or array-like value. Inside this value, it looks for a key named zend-expressive-session-cache , which is expected to be an associative array or object that acts like an associative array. return [ 'zend-expressive-session-cache' => [ // key/value pairs ], ];","title":"Config service"},{"location":"v1/config/#cacheitempoolinterface","text":"By default, the factory will look for a service named Psr\\Cache\\CacheItemPoolInterface . If found, that service will be used to seed the persistence adapter. You may also provide a cache_item_pool_service configuration value. If present, this service name will be queried instead.","title":"CacheItemPoolInterface"},{"location":"v1/config/#non-pool-configuration","text":"As noted earlier, you may configure a number of other values to customize your persistence adapter. The following is example configuration, with inline comments detailing expected and default values. use Psr\\Cache\\CacheItemPoolInterface; return [ 'zend-expressive-session-cache' => [ // Detailed in the above section; allows using a different // cache item pool than the global one. 'cache_item_pool_service' => CacheItemPoolInterface::class, // The name of the session cookie. This name must comply with // the syntax outlined in https://tools.ietf.org/html/rfc6265.html 'cookie_name' => 'PHPSESSION', // The (sub)domain that the cookie is available to. Setting this // to a subdomain (such as 'www.example.com') will make the cookie // available to that subdomain and all other sub-domains of it // (i.e. w2.www.example.com). To make the cookie available to the // whole domain (including all subdomains of it), simply set the // value to the domain name ('example.com', in this case). // Leave this null to use browser default (current hostname). 'cookie_domain' => null, // The path prefix of the cookie domain to which it applies. 'cookie_path' => '/', // Indicates that the cookie should only be transmitted over a // secure HTTPS connection from the client. When set to TRUE, the // cookie will only be set if a secure connection exists. 'cookie_secure' => false, // When TRUE the cookie will be made accessible only through the // HTTP protocol. This means that the cookie won't be accessible // by scripting languages, such as JavaScript. 'cookie_http_only' => false, // Governs the various cache control headers emitted when // a session cookie is provided to the client. Value may be one // of \"nocache\", \"public\", \"private\", or \"private_no_expire\"; // semantics are the same as outlined in // http://php.net/session_cache_limiter 'cache_limiter' => 'nocache', // When the cache and the cookie should expire, in seconds. Defaults // to 180 minutes. 'cache_expire' => 10800, // An integer value indicating when the resource to which the session // applies was last modified. If not provided, it uses the last // modified time of, in order, // - the public/index.php file of the current working directory // - the index.php file of the current working directory // - the current working directory 'last_modified' => null, // A boolean value indicating whether or not the session cookie // should persist. By default, this is disabled (false); passing // a boolean true value will enable the feature. When enabled, the // cookie will be generated with an Expires directive equal to the // the current time plus the cache_expire value as noted above. // // As of 1.2.0, developers may define the session TTL by calling the // session instance's `persistSessionFor(int $duration)` method. When // that method has been called, the engine will use that value even if // the below flag is toggled off. 'persistent' => false, ], ];","title":"Non-Pool configuration"},{"location":"v1/config/#using-the-service","text":"By default, this package define the service Zend\\Expressive\\Session\\Cache\\CacheSessionPersistence , assigning it to the factory Zend\\Expressive\\Session\\Cache\\CacheSessionPersistenceFactory . After you have installed the package, you will need to tell your application to use this service when using the SessionMiddleware . The SessionMiddleware looks for the service Zend\\Expressive\\Session\\SessionPersistenceInterface . You can tell your container to use the CacheSessionPersistence in two different ways. First, you can alias it: // in config/autoload/dependencies.global.php: use Zend\\Expressive\\Session\\Cache\\CacheSessionPersistence; use Zend\\Expressive\\Session\\SessionPersistenceInterface; return [ 'dependencies' => [ 'aliases' => [ SessionPersistenceInterface::class => CacheSessionPersistence::class, ], ], ]; Second, you can instead assign the SessionPersistenceInterface service to the factory for the CacheSessionPersistence implementation: // in config/autoload/dependencies.global.php: use Zend\\Expressive\\Session\\Cache\\CacheSessionPersistenceFactory; use Zend\\Expressive\\Session\\SessionPersistenceInterface; return [ 'dependencies' => [ 'factories' => [ SessionPersistenceInterface::class => CacheSessionPersistenceFactory::class, ], ], ];","title":"Using the service"},{"location":"v1/intro/","text":"Introduction This component provides a PSR-6 session persistence adapter for use with zend-expressive-session . PSR-6 defines cache items and cache item pools. This package uses a cache item pool in which to store and retrieve sessions. PSR-6 was chosen over the simpler PSR-16 as it specifically provides functionality around expiry , which allows us to expire sessions. Installation Install zend-expressive-session-cache via Composer : $ composer require zendframework/zend-expressive-session-cache You will also need to install a package that provides a PSR-6 CacheItemPoolInterface implementation. You can search for PSR-6 providers on Packagist . We have had excellent luck with the various implementations provided by the PHP-Cache project . Usage Generally, you will only provide configuration for this service, including configuring a PSR-6 CacheItemPoolInterface service; zend-expressive-session will then consume it via its SessionMiddleware .","title":"Introduction"},{"location":"v1/intro/#introduction","text":"This component provides a PSR-6 session persistence adapter for use with zend-expressive-session . PSR-6 defines cache items and cache item pools. This package uses a cache item pool in which to store and retrieve sessions. PSR-6 was chosen over the simpler PSR-16 as it specifically provides functionality around expiry , which allows us to expire sessions.","title":"Introduction"},{"location":"v1/intro/#installation","text":"Install zend-expressive-session-cache via Composer : $ composer require zendframework/zend-expressive-session-cache You will also need to install a package that provides a PSR-6 CacheItemPoolInterface implementation. You can search for PSR-6 providers on Packagist . We have had excellent luck with the various implementations provided by the PHP-Cache project .","title":"Installation"},{"location":"v1/intro/#usage","text":"Generally, you will only provide configuration for this service, including configuring a PSR-6 CacheItemPoolInterface service; zend-expressive-session will then consume it via its SessionMiddleware .","title":"Usage"},{"location":"v1/manual/","text":"Manual usage The following details the constructor of the Zend\\Expressive\\Session\\Cache\\CacheSessionPersistence class: /** * Prepare session cache and default HTTP caching headers. * * @param CacheItemPoolInterface $cache The cache pool instance * @param string $cookieName The name of the cookie * @param string $cacheLimiter The cache limiter setting is used to * determine how to send HTTP client-side caching headers. Those * headers will be added programmatically to the response along with * the session set-cookie header when the session data is persisted. * @param int $cacheExpire Number of seconds until the session cookie * should expire; defaults to 180 minutes (180m * 60s/m = 10800s), * which is the default of the PHP session.cache_expire setting. This * is also used to set the TTL for session data. * @param null|int $lastModified Timestamp when the application was last * modified. If not provided, this will look for each of * public/index.php, index.php, and finally the current working * directory, using the filemtime() of the first found. * @param bool $persistent Whether or not to create a persistent cookie. If * provided, this sets the Expires directive for the cookie based on * the value of $cacheExpire. Developers can also set the expiry at * runtime via the Session instance, using its persistSessionFor() * method; that value will be honored even if global persistence * is toggled true here. * @param string|null $cookieDomain The domain for the cookie. If not set, * the current domain is used. * @param bool $cookieSecure Whether or not the cookie should be required * to be set over an encrypted connection * @param bool $cookieHttpOnly Whether or not the cookie may be accessed * by client-side apis (e.g., Javascript). An http-only cookie cannot * be accessed by client-side apis. * * @todo reorder these arguments so they make more sense and are in an * order of importance */ public function __construct( CacheItemPoolInterface $cache, string $cookieName, string $cookiePath = '/', string $cacheLimiter = 'nocache', int $cacheExpire = 10800, ?int $lastModified = null, bool $persistent = false, string $cookieDomain = null, bool $cookieSecure = false, bool $cookieHttpOnly = false ) { Pass all required values and any optional values when creating an instance: use Cache\\Adapter\\Predis\\PredisCachePool; use Zend\\Expressive\\Session\\Cache\\CacheSessionPersistence; use Zend\\Expressive\\Session\\SessionMiddleware; $cachePool = new PredisCachePool('tcp://localhost:6379'); $persistence = new CacheSessionPersistence( $cachePool, 'MYSITE' '/', 'public', 60 * 60 * 24 * 30 // 30 days ); $middleware = new SessionMiddleware($persistence);","title":"Manual Usage"},{"location":"v1/manual/#manual-usage","text":"The following details the constructor of the Zend\\Expressive\\Session\\Cache\\CacheSessionPersistence class: /** * Prepare session cache and default HTTP caching headers. * * @param CacheItemPoolInterface $cache The cache pool instance * @param string $cookieName The name of the cookie * @param string $cacheLimiter The cache limiter setting is used to * determine how to send HTTP client-side caching headers. Those * headers will be added programmatically to the response along with * the session set-cookie header when the session data is persisted. * @param int $cacheExpire Number of seconds until the session cookie * should expire; defaults to 180 minutes (180m * 60s/m = 10800s), * which is the default of the PHP session.cache_expire setting. This * is also used to set the TTL for session data. * @param null|int $lastModified Timestamp when the application was last * modified. If not provided, this will look for each of * public/index.php, index.php, and finally the current working * directory, using the filemtime() of the first found. * @param bool $persistent Whether or not to create a persistent cookie. If * provided, this sets the Expires directive for the cookie based on * the value of $cacheExpire. Developers can also set the expiry at * runtime via the Session instance, using its persistSessionFor() * method; that value will be honored even if global persistence * is toggled true here. * @param string|null $cookieDomain The domain for the cookie. If not set, * the current domain is used. * @param bool $cookieSecure Whether or not the cookie should be required * to be set over an encrypted connection * @param bool $cookieHttpOnly Whether or not the cookie may be accessed * by client-side apis (e.g., Javascript). An http-only cookie cannot * be accessed by client-side apis. * * @todo reorder these arguments so they make more sense and are in an * order of importance */ public function __construct( CacheItemPoolInterface $cache, string $cookieName, string $cookiePath = '/', string $cacheLimiter = 'nocache', int $cacheExpire = 10800, ?int $lastModified = null, bool $persistent = false, string $cookieDomain = null, bool $cookieSecure = false, bool $cookieHttpOnly = false ) { Pass all required values and any optional values when creating an instance: use Cache\\Adapter\\Predis\\PredisCachePool; use Zend\\Expressive\\Session\\Cache\\CacheSessionPersistence; use Zend\\Expressive\\Session\\SessionMiddleware; $cachePool = new PredisCachePool('tcp://localhost:6379'); $persistence = new CacheSessionPersistence( $cachePool, 'MYSITE' '/', 'public', 60 * 60 * 24 * 30 // 30 days ); $middleware = new SessionMiddleware($persistence);","title":"Manual usage"}]}