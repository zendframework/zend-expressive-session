{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-expressive-session This library provides session handling middleware for PSR-7 applications, using an adapter-based approach that will allow usage of ext-session, JWT, or other approaches. Installation Run the following to install this library: $ composer require zendframework/zend-expressive-session However, the package is not immediately useful unless you have a persistence adapter. If you are okay with using ext-session, you can install the following package as well: $ composer require zendframework/zend-expressive-session-ext Documentation Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"zend-expressive-session"},{"location":"#zend-expressive-session","text":"This library provides session handling middleware for PSR-7 applications, using an adapter-based approach that will allow usage of ext-session, JWT, or other approaches.","title":"zend-expressive-session"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-expressive-session However, the package is not immediately useful unless you have a persistence adapter. If you are okay with using ext-session, you can install the following package as well: $ composer require zendframework/zend-expressive-session-ext","title":"Installation"},{"location":"#documentation","text":"Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Documentation"},{"location":"intro/","text":"zend-expressive-session Web applications often need to persist user state between requests, and the generally accepted way to do so is via sessions . While PHP provides its own session extension, it: uses global functions that affect global state. relies on a superglobal for access to both read and write the session data. incurs either filesystem or network I/O on every request, depending on the session storage handler. can clobber the Set-Cookie header when other processes also set it. Some projects, such as psr-7-sessions/storageless , take a different approach, using JSON Web Tokens (JWT). The goals of zend-expressive-session are: to abstract the way users interact with session storage. to abstract how sessions are persisted, to allow both standard ext-session, but also other paradigms such as JWT. to provide session capabilities that \"play nice\" with PSR-7 and middleware. Installation Use Composer to install this package: $ composer require zendframework/zend-expressive-session However, the package is not immediately useful unless you have a persistence adapter. If you are okay with using ext-session, you can install the following package as well: $ composer require zendframework/zend-expressive-session-ext Features zend-expressive-session provides the following: Interfaces for: session containers session persistence An implementation of the session container. A \"lazy-loading\" implementation of the session container, to allow delaying any de/serialization and/or I/O processes until session data is requested; this implementation decorates a normal session container. PSR-7 middleware that: composes a session persistence implementation. initializes the lazy-loading session container, using the session persistence implementation. delegates to the next middleware, passing the session container into the request. finalizes the session before returning the response. Persistence implementations locate session information from the requests (e.g., via a cookie) in order to initialize the session. On completion of the request, they examine the session container for changes and/or to see if it is empty, and provide data to the response so as to notify the client of the session (e.g., via a Set-Cookie header). Note that the goals of this package are solely focused on session persistence and access to session data by middleware . If you also need other features often related to session data, you may want to consider the following packages: zend-expressive-flash : provides flash message capabilities. zend-expressive-csrf : provides CSRF token generation, storage, and verification, using either a session container, or flash messages.","title":"Introduction"},{"location":"intro/#zend-expressive-session","text":"Web applications often need to persist user state between requests, and the generally accepted way to do so is via sessions . While PHP provides its own session extension, it: uses global functions that affect global state. relies on a superglobal for access to both read and write the session data. incurs either filesystem or network I/O on every request, depending on the session storage handler. can clobber the Set-Cookie header when other processes also set it. Some projects, such as psr-7-sessions/storageless , take a different approach, using JSON Web Tokens (JWT). The goals of zend-expressive-session are: to abstract the way users interact with session storage. to abstract how sessions are persisted, to allow both standard ext-session, but also other paradigms such as JWT. to provide session capabilities that \"play nice\" with PSR-7 and middleware.","title":"zend-expressive-session"},{"location":"intro/#installation","text":"Use Composer to install this package: $ composer require zendframework/zend-expressive-session However, the package is not immediately useful unless you have a persistence adapter. If you are okay with using ext-session, you can install the following package as well: $ composer require zendframework/zend-expressive-session-ext","title":"Installation"},{"location":"intro/#features","text":"zend-expressive-session provides the following: Interfaces for: session containers session persistence An implementation of the session container. A \"lazy-loading\" implementation of the session container, to allow delaying any de/serialization and/or I/O processes until session data is requested; this implementation decorates a normal session container. PSR-7 middleware that: composes a session persistence implementation. initializes the lazy-loading session container, using the session persistence implementation. delegates to the next middleware, passing the session container into the request. finalizes the session before returning the response. Persistence implementations locate session information from the requests (e.g., via a cookie) in order to initialize the session. On completion of the request, they examine the session container for changes and/or to see if it is empty, and provide data to the response so as to notify the client of the session (e.g., via a Set-Cookie header). Note that the goals of this package are solely focused on session persistence and access to session data by middleware . If you also need other features often related to session data, you may want to consider the following packages: zend-expressive-flash : provides flash message capabilities. zend-expressive-csrf : provides CSRF token generation, storage, and verification, using either a session container, or flash messages.","title":"Features"},{"location":"middleware/","text":"Session Middleware zend-expressive-session provides middleware consuming PSR-7 HTTP message instances, via implementation of PSR-15 interfaces. This middleware composes a persistence instance, and uses that in order to generate a session container, which it pushes into the request it delegates to the next middleware. Once a response is returned, it uses the persistence instance to persist the session data and provide information back to the client. The above two paragraphs are longer than the body of the middleware implementation: namespace Zend\\Expressive\\Session; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class SessionMiddleware implements MiddlewareInterface { public const SESSION_ATTRIBUTE = 'session'; private $persistence; public function __construct(SessionPersistenceInterface $persistence) { $this->persistence = $persistence; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $session = new LazySession($this->persistence, $request); $response = $handler->handle($request->withAttribute(self::SESSION_ATTRIBUTE, $session)); return $this->persistence->persistSession($session, $response); } } Configuration This package provides a factory for Zend\\Expressive\\Session\\SessionMiddleware via Zend\\Expressive\\Session\\SessionMiddlewareFactory ; this factory is auto-wired if you are using Expressive and the zend-component-installer Composer plugin. If not, you will need to wire these into your application. The factory depends on one service: Zend\\Expressive\\Session\\SessionPersistenceInterface . You will need to either wire in your persistence implementation of choice, or have the package providing it do so for you. Adding the middleware to your application You may pipe this middleware anywhere in your application. If you want to have it available anywhere, pipe it early in your application, prior to any routing. As an example, within Expressive, you could pipe it in the config/pipeline.php file: $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class); $app->pipeRoutingMiddleware(); This will generally be an inexpensive operation; since the middleware uses a LazySession instance, unless your persistence implementation does any work in its constructor, the cost is just that of instantiating a few objects. However, it's often useful to specifically include such middleware directly in the routed middleware pipelines, to ensure other developers are aware of its presence in that route's workflow. Within Expressive, you can do this when routing, in your config/routes.php file, or within a delegator factory : $app->post('/login', [ \\Zend\\Expressive\\Session\\SessionMiddleware::class, \\User\\Middleware\\LoginHandler::class ]);","title":"Session Middleware"},{"location":"middleware/#session-middleware","text":"zend-expressive-session provides middleware consuming PSR-7 HTTP message instances, via implementation of PSR-15 interfaces. This middleware composes a persistence instance, and uses that in order to generate a session container, which it pushes into the request it delegates to the next middleware. Once a response is returned, it uses the persistence instance to persist the session data and provide information back to the client. The above two paragraphs are longer than the body of the middleware implementation: namespace Zend\\Expressive\\Session; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class SessionMiddleware implements MiddlewareInterface { public const SESSION_ATTRIBUTE = 'session'; private $persistence; public function __construct(SessionPersistenceInterface $persistence) { $this->persistence = $persistence; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $session = new LazySession($this->persistence, $request); $response = $handler->handle($request->withAttribute(self::SESSION_ATTRIBUTE, $session)); return $this->persistence->persistSession($session, $response); } }","title":"Session Middleware"},{"location":"middleware/#configuration","text":"This package provides a factory for Zend\\Expressive\\Session\\SessionMiddleware via Zend\\Expressive\\Session\\SessionMiddlewareFactory ; this factory is auto-wired if you are using Expressive and the zend-component-installer Composer plugin. If not, you will need to wire these into your application. The factory depends on one service: Zend\\Expressive\\Session\\SessionPersistenceInterface . You will need to either wire in your persistence implementation of choice, or have the package providing it do so for you.","title":"Configuration"},{"location":"middleware/#adding-the-middleware-to-your-application","text":"You may pipe this middleware anywhere in your application. If you want to have it available anywhere, pipe it early in your application, prior to any routing. As an example, within Expressive, you could pipe it in the config/pipeline.php file: $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class); $app->pipeRoutingMiddleware(); This will generally be an inexpensive operation; since the middleware uses a LazySession instance, unless your persistence implementation does any work in its constructor, the cost is just that of instantiating a few objects. However, it's often useful to specifically include such middleware directly in the routed middleware pipelines, to ensure other developers are aware of its presence in that route's workflow. Within Expressive, you can do this when routing, in your config/routes.php file, or within a delegator factory : $app->post('/login', [ \\Zend\\Expressive\\Session\\SessionMiddleware::class, \\User\\Middleware\\LoginHandler::class ]);","title":"Adding the middleware to your application"},{"location":"persistence/","text":"Session Persistence Session persistence within zend-expressive-session refers to one or both of the following: Identifying session information provided by the client making the request. Storing session data for access on subsequent requests. Providing session information to the client making the request. In some scenarios, such as usage of JSON Web Tokens (JWT), the serialized session data is provided by the client, and provided to the client directly, without any server-side storage whatsoever. To describe these operations, we provide Zend\\Expressive\\Session\\SessionPersistenceInterface : namespace Zend\\Expressive\\Session; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; interface SessionPersistenceInterface { /** * Generate a session data instance based on the request. */ public function initializeSessionFromRequest(ServerRequestInterface $request) : SessionInterface; /** * Persist the session data instance. * * Persists the session data, returning a response instance with any * artifacts required to return to the client. */ public function persistSession(SessionInterface $session, ResponseInterface $response) : ResponseInterface; } Session initialization pulls data from the request (a cookie, a header value, etc.) in order to produce a session container. Session persistence pulls data from the session container, does something with it, and then optionally provides a response containing session artifacts (a cookie, a header value, etc.). For sessions to work, you must provide a persistence implementation . We provide one such implementation using PHP's session extension via the package zend-expressive-session-ext . Session identifiers Typically, the session identifier will be retrieved from the request (usually via a cookie), and a new identifier created if none was discovered. During persistence, if an existing session's contents have changed, or regenerateId() was called on the session, the persistence implementation becomes responsible for: Removing the original session. Generating a new identifier for the session. In all situations, it then needs to store the session data in such a way that a later lookup by the current identifier will retrieve that data. Prior to version 1.1.0, persistence engines had two ways to determine what the original session identifier was when it came time to regenerate or persist a session: Store the identifier as a property of the persistence implementation. Store the identifier in the session data under a \"magic\" key (e.g., __SESSION_ID__ ). The first approach is problematic when using zend-expressive-session in an async environment such as Swoole or ReactPHP , as the same persistence instance may be used by several simultaneous requests. As such, version 1.1.0 introduces a new interface for Zend\\Expressive\\Session\\SessionInterface implementations to use: Zend\\Expressive\\Session\\SessionIdentifierAwareInterface . This interface defines a single method, getId() ; implementations can thus store the identifier internally, and, when it comes time to store the session data, persistence implementations can query that method in order to retrieve the session identifier. Considering that persistence implementations also create the session instance, we recommend that implementations only create instances that implement the SessionIdentifierAwareInterface going forward in order to make themselves async compatible. Persistent sessions Since 1.2.0. If your persistence implementation supports persistent sessions \u2014 for example, by setting an Expires or Max-Age cookie directive \u2014 then you can opt to globally set a default session duration, or allow developers to hint a desired session duration via the session container using SessionContainerPersistenceInterface::persistSessionFor() . Implementations SHOULD honor the value of SessionContainerPersistenceInterface::getSessionLifetime() when persisting the session data. This could mean either or both of the following: Ensuring that the session data will not be purged until after the specified TTL value. Setting an Expires or Max-Age cookie directive. In each case, the persistence engine should query the Session instance for a TTL value: $ttl = $session instanceof SessionContainerPersistenceInterface ? $session->getSessionLifetime() : $defaultLifetime; // likely 0, to indicate automatic expiry getSessionLifetime() returns an integer value indicating the number of seconds the session should persist.","title":"Session Persistence"},{"location":"persistence/#session-persistence","text":"Session persistence within zend-expressive-session refers to one or both of the following: Identifying session information provided by the client making the request. Storing session data for access on subsequent requests. Providing session information to the client making the request. In some scenarios, such as usage of JSON Web Tokens (JWT), the serialized session data is provided by the client, and provided to the client directly, without any server-side storage whatsoever. To describe these operations, we provide Zend\\Expressive\\Session\\SessionPersistenceInterface : namespace Zend\\Expressive\\Session; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; interface SessionPersistenceInterface { /** * Generate a session data instance based on the request. */ public function initializeSessionFromRequest(ServerRequestInterface $request) : SessionInterface; /** * Persist the session data instance. * * Persists the session data, returning a response instance with any * artifacts required to return to the client. */ public function persistSession(SessionInterface $session, ResponseInterface $response) : ResponseInterface; } Session initialization pulls data from the request (a cookie, a header value, etc.) in order to produce a session container. Session persistence pulls data from the session container, does something with it, and then optionally provides a response containing session artifacts (a cookie, a header value, etc.). For sessions to work, you must provide a persistence implementation . We provide one such implementation using PHP's session extension via the package zend-expressive-session-ext .","title":"Session Persistence"},{"location":"persistence/#session-identifiers","text":"Typically, the session identifier will be retrieved from the request (usually via a cookie), and a new identifier created if none was discovered. During persistence, if an existing session's contents have changed, or regenerateId() was called on the session, the persistence implementation becomes responsible for: Removing the original session. Generating a new identifier for the session. In all situations, it then needs to store the session data in such a way that a later lookup by the current identifier will retrieve that data. Prior to version 1.1.0, persistence engines had two ways to determine what the original session identifier was when it came time to regenerate or persist a session: Store the identifier as a property of the persistence implementation. Store the identifier in the session data under a \"magic\" key (e.g., __SESSION_ID__ ). The first approach is problematic when using zend-expressive-session in an async environment such as Swoole or ReactPHP , as the same persistence instance may be used by several simultaneous requests. As such, version 1.1.0 introduces a new interface for Zend\\Expressive\\Session\\SessionInterface implementations to use: Zend\\Expressive\\Session\\SessionIdentifierAwareInterface . This interface defines a single method, getId() ; implementations can thus store the identifier internally, and, when it comes time to store the session data, persistence implementations can query that method in order to retrieve the session identifier. Considering that persistence implementations also create the session instance, we recommend that implementations only create instances that implement the SessionIdentifierAwareInterface going forward in order to make themselves async compatible.","title":"Session identifiers"},{"location":"persistence/#persistent-sessions","text":"Since 1.2.0. If your persistence implementation supports persistent sessions \u2014 for example, by setting an Expires or Max-Age cookie directive \u2014 then you can opt to globally set a default session duration, or allow developers to hint a desired session duration via the session container using SessionContainerPersistenceInterface::persistSessionFor() . Implementations SHOULD honor the value of SessionContainerPersistenceInterface::getSessionLifetime() when persisting the session data. This could mean either or both of the following: Ensuring that the session data will not be purged until after the specified TTL value. Setting an Expires or Max-Age cookie directive. In each case, the persistence engine should query the Session instance for a TTL value: $ttl = $session instanceof SessionContainerPersistenceInterface ? $session->getSessionLifetime() : $defaultLifetime; // likely 0, to indicate automatic expiry getSessionLifetime() returns an integer value indicating the number of seconds the session should persist.","title":"Persistent sessions"},{"location":"session/","text":"Session Containers Session containers are the primary interface with which most application developers will work; they contain the data currently in the session, and allow you to push data to the session. All session containers implement Zend\\Expressive\\Session\\SessionInterface : namespace Zend\\Expressive\\Session; interface SessionInterface { /** * Serialize the session data to an array for storage purposes. */ public function toArray() : array; /** * Retrieve a value from the session. * * @param mixed $default Default value to return if $name does not exist. * @return mixed */ public function get(string $name, $default = null); /** * Whether or not the container has the given key. */ public function has(string $name) : bool; /** * Set a value within the session. * * Values MUST be serializable in any format; we recommend ensuring the * values are JSON serializable for greatest portability. * * @param mixed $value */ public function set(string $name, $value) : void; /** * Remove a value from the session. */ public function unset(string $name) : void; /** * Clear all values. */ public function clear() : void; /** * Does the session contain changes? If not, the middleware handling * session persistence may not need to do more work. */ public function hasChanged() : bool; /** * Regenerate the session. * * This can be done to prevent session fixation. When executed, it SHOULD * return a new instance; that instance should always return true for * isRegenerated(). * * An example of where this WOULD NOT return a new instance is within the * shipped LazySession, where instead it would return itself, after * internally re-setting the proxied session. */ public function regenerate(): SessionInterface; /** * Method to determine if the session was regenerated; should return * true if the instance was produced via regenerate(). */ public function isRegenerated() : bool; } The default implementation, and the one you'll most likely interact with, is Zend\\Expressive\\Session\\Session . Since version 1.1.0, we provide Zend\\Expressive\\Session\\SessionIdentifierAwareInterface : namespace Zend\\Expressive\\Session; interface SessionIdentifierAwareInterface { /** * Retrieve the session identifier. * * This feature was added in 1.1.0 to allow the session persistence to be * stateless. Previously, persistence implementations had to store the * session identifier between calls to initializeSessionFromRequest() and * persistSession(). When SessionInterface implementations also implement * this method, the persistence implementation no longer needs to store it. * * This method will become a part of the SessionInterface in 2.0.0. * * @since 1.1.0 */ public function getId() : string; } Since version 1.2.0, we provide Zend\\Expressive\\Session\\SessionCookiePersistenceInterface : namespace Zend\\Expressive\\Session; /** * Allow marking session cookies as persistent. * * It can be useful to mark a session as persistent: e.g., for a \"Remember Me\" * feature when logging a user into your system. PHP provides this capability * via ext-session with the $lifetime argument to session_set_cookie_params() * as well as by the session.cookie_lifetime INI setting. The latter will set * the value for all session cookies sent (or until the value is changed via * an ini_set() call), while the former will only affect cookies created during * the current script lifetime. * * Persistence engines may, of course, allow setting a global lifetime. This * interface allows developers to set the lifetime programmatically. Persistence * implementations are encouraged to use the value to set the cookie lifetime * when creating and returning a cookie. Additionally, to ensure the cookie * lifetime originally requested is honored when a session is regenerated, we * recommend persistence engines to store the TTL in the session data itself, * so that it can be re-sent in such scenarios. */ interface SessionCookiePersistenceInterface { const SESSION_LIFETIME_KEY = '__SESSION_TTL__'; /** * Define how long the session cookie should live. * * Use this value to detail to the session persistence engine how long the * session cookie should live. * * This value could be passed as the $lifetime value of * session_set_cookie_params(), or used to create an Expires or Max-Age * parameter for a session cookie. * * Since cookie lifetime is communicated by the server to the client, and * not vice versa, the value should likely be persisted in the session * itself, to ensure that session regeneration uses the same value. We * recommend using the SESSION_LIFETIME_KEY value to communicate this. * * @param int $duration Number of seconds the cookie should persist for. */ public function persistSessionFor(int $duration) : void; /** * Determine how long the session cookie should live. * * Generally, this will return the value provided to persistFor(). * * If that method has not been called, the value can return one of the * following: * * - 0 or a negative value, to indicate the cookie should be treated as a * session cookie, and expire when the window is closed. This should be * the default behavior. * - If persistFor() was provided during session creation or anytime later, * the persistence engine should pull the TTL value from the session itself * and return it here. Typically, this value should be communicated via * the SESSION_LIFETIME_KEY value of the session. */ public function getSessionLifetime() : int; } Zend\\Expressive\\Session\\Session and Zend\\Expressive\\Session\\LazySession both implement each of the interfaces listed above. Session accepts an optional identifier to its constructor, and will use the value of the SessionCookiePersistenceInterface::SESSION_LIFETIME_KEY in the provided data to seed the session cookie lifetime, if present. Usage Session containers will typically be passed to your middleware using the SessionMiddleware , via the Zend\\Expressive\\Session\\SessionMiddleware::SESSION_ATTRIBUTE (\"session\") request attribute. Once you have the container, you can check for data: if ($session->has('user')) { } and retrieve it: $user = $session->get('user'); You can combine those operations, by passing a default value as a second argument to the get() method: $user = $session->get('user', new GuestUser()); If a datum is no longer relevant in the session, unset() it: $session->unset('user'); If none of the data is relevant, clear() the session: $session->clear(); Persistent Sessions Since 1.2.0 You can hint to the session persistence engine how long the session should persist: $session->persistSessionFor(60 * 60 * 24 * 7); // persist for 7 days To make the session expire when the browser session is terminated (default behavior), use zero or a negative integer: $session->persistSessionFor(0); // expire data after session is over Lazy Sessions This package provides another implementation of SessionInterface via Zend\\Expressive\\Session\\LazySession . This implementation does the following: It composes a persistence instance, along with the current request. On first access (e.g., get() , set() , etc.), it uses the composed persistence and request instances to generate the actual session container. All methods then proxy to this container. This approach helps delay any I/O or network operations, and/or deserialization, until they are actually needed. The shipped SessionMiddleware produces a LazySession . Session Regeneration Some application events benefit from session regeneration . In particular, after a user has successfully logged in or out, you will generally want to regenerate the session in order to prevent session fixation and the attack vectors it invites. In those situations, call regenerate() : $newSession = $session->regenerate(); The interface indicates that a new instance should be returned. However, in the default usage, you will have a LazySession instance (as described above), which decorates the underlying session storage. This is done for two reasons: First, the stated reasons of preventing the need to deserialize data and/or perform I/O access until the last moment. Second, to ensure that the SessionMiddleware always has a pointer to the session . This latter is what allows you to regenerate the session in middleware nested deep in your application, but still have the data persisted correctly.","title":"Session Containers"},{"location":"session/#session-containers","text":"Session containers are the primary interface with which most application developers will work; they contain the data currently in the session, and allow you to push data to the session. All session containers implement Zend\\Expressive\\Session\\SessionInterface : namespace Zend\\Expressive\\Session; interface SessionInterface { /** * Serialize the session data to an array for storage purposes. */ public function toArray() : array; /** * Retrieve a value from the session. * * @param mixed $default Default value to return if $name does not exist. * @return mixed */ public function get(string $name, $default = null); /** * Whether or not the container has the given key. */ public function has(string $name) : bool; /** * Set a value within the session. * * Values MUST be serializable in any format; we recommend ensuring the * values are JSON serializable for greatest portability. * * @param mixed $value */ public function set(string $name, $value) : void; /** * Remove a value from the session. */ public function unset(string $name) : void; /** * Clear all values. */ public function clear() : void; /** * Does the session contain changes? If not, the middleware handling * session persistence may not need to do more work. */ public function hasChanged() : bool; /** * Regenerate the session. * * This can be done to prevent session fixation. When executed, it SHOULD * return a new instance; that instance should always return true for * isRegenerated(). * * An example of where this WOULD NOT return a new instance is within the * shipped LazySession, where instead it would return itself, after * internally re-setting the proxied session. */ public function regenerate(): SessionInterface; /** * Method to determine if the session was regenerated; should return * true if the instance was produced via regenerate(). */ public function isRegenerated() : bool; } The default implementation, and the one you'll most likely interact with, is Zend\\Expressive\\Session\\Session . Since version 1.1.0, we provide Zend\\Expressive\\Session\\SessionIdentifierAwareInterface : namespace Zend\\Expressive\\Session; interface SessionIdentifierAwareInterface { /** * Retrieve the session identifier. * * This feature was added in 1.1.0 to allow the session persistence to be * stateless. Previously, persistence implementations had to store the * session identifier between calls to initializeSessionFromRequest() and * persistSession(). When SessionInterface implementations also implement * this method, the persistence implementation no longer needs to store it. * * This method will become a part of the SessionInterface in 2.0.0. * * @since 1.1.0 */ public function getId() : string; } Since version 1.2.0, we provide Zend\\Expressive\\Session\\SessionCookiePersistenceInterface : namespace Zend\\Expressive\\Session; /** * Allow marking session cookies as persistent. * * It can be useful to mark a session as persistent: e.g., for a \"Remember Me\" * feature when logging a user into your system. PHP provides this capability * via ext-session with the $lifetime argument to session_set_cookie_params() * as well as by the session.cookie_lifetime INI setting. The latter will set * the value for all session cookies sent (or until the value is changed via * an ini_set() call), while the former will only affect cookies created during * the current script lifetime. * * Persistence engines may, of course, allow setting a global lifetime. This * interface allows developers to set the lifetime programmatically. Persistence * implementations are encouraged to use the value to set the cookie lifetime * when creating and returning a cookie. Additionally, to ensure the cookie * lifetime originally requested is honored when a session is regenerated, we * recommend persistence engines to store the TTL in the session data itself, * so that it can be re-sent in such scenarios. */ interface SessionCookiePersistenceInterface { const SESSION_LIFETIME_KEY = '__SESSION_TTL__'; /** * Define how long the session cookie should live. * * Use this value to detail to the session persistence engine how long the * session cookie should live. * * This value could be passed as the $lifetime value of * session_set_cookie_params(), or used to create an Expires or Max-Age * parameter for a session cookie. * * Since cookie lifetime is communicated by the server to the client, and * not vice versa, the value should likely be persisted in the session * itself, to ensure that session regeneration uses the same value. We * recommend using the SESSION_LIFETIME_KEY value to communicate this. * * @param int $duration Number of seconds the cookie should persist for. */ public function persistSessionFor(int $duration) : void; /** * Determine how long the session cookie should live. * * Generally, this will return the value provided to persistFor(). * * If that method has not been called, the value can return one of the * following: * * - 0 or a negative value, to indicate the cookie should be treated as a * session cookie, and expire when the window is closed. This should be * the default behavior. * - If persistFor() was provided during session creation or anytime later, * the persistence engine should pull the TTL value from the session itself * and return it here. Typically, this value should be communicated via * the SESSION_LIFETIME_KEY value of the session. */ public function getSessionLifetime() : int; } Zend\\Expressive\\Session\\Session and Zend\\Expressive\\Session\\LazySession both implement each of the interfaces listed above. Session accepts an optional identifier to its constructor, and will use the value of the SessionCookiePersistenceInterface::SESSION_LIFETIME_KEY in the provided data to seed the session cookie lifetime, if present.","title":"Session Containers"},{"location":"session/#usage","text":"Session containers will typically be passed to your middleware using the SessionMiddleware , via the Zend\\Expressive\\Session\\SessionMiddleware::SESSION_ATTRIBUTE (\"session\") request attribute. Once you have the container, you can check for data: if ($session->has('user')) { } and retrieve it: $user = $session->get('user'); You can combine those operations, by passing a default value as a second argument to the get() method: $user = $session->get('user', new GuestUser()); If a datum is no longer relevant in the session, unset() it: $session->unset('user'); If none of the data is relevant, clear() the session: $session->clear();","title":"Usage"},{"location":"session/#persistent-sessions","text":"Since 1.2.0 You can hint to the session persistence engine how long the session should persist: $session->persistSessionFor(60 * 60 * 24 * 7); // persist for 7 days To make the session expire when the browser session is terminated (default behavior), use zero or a negative integer: $session->persistSessionFor(0); // expire data after session is over","title":"Persistent Sessions"},{"location":"session/#lazy-sessions","text":"This package provides another implementation of SessionInterface via Zend\\Expressive\\Session\\LazySession . This implementation does the following: It composes a persistence instance, along with the current request. On first access (e.g., get() , set() , etc.), it uses the composed persistence and request instances to generate the actual session container. All methods then proxy to this container. This approach helps delay any I/O or network operations, and/or deserialization, until they are actually needed. The shipped SessionMiddleware produces a LazySession .","title":"Lazy Sessions"},{"location":"session/#session-regeneration","text":"Some application events benefit from session regeneration . In particular, after a user has successfully logged in or out, you will generally want to regenerate the session in order to prevent session fixation and the attack vectors it invites. In those situations, call regenerate() : $newSession = $session->regenerate(); The interface indicates that a new instance should be returned. However, in the default usage, you will have a LazySession instance (as described above), which decorates the underlying session storage. This is done for two reasons: First, the stated reasons of preventing the need to deserialize data and/or perform I/O access until the last moment. Second, to ensure that the SessionMiddleware always has a pointer to the session . This latter is what allows you to regenerate the session in middleware nested deep in your application, but still have the data persisted correctly.","title":"Session Regeneration"}]}